{
  "version": 1,
  "width": 88,
  "height": 26,
  "duration": 8.285865,
  "command": "/usr/bin/zsh",
  "title": "",
  "env": {
    "TERM": "screen",
    "SHELL": "/usr/bin/zsh"
  },
  "stdout": [
    [
      0.164758,
      "\u001b[1m\u001b[3m%\u001b[23m\u001b[1m\u001b[0m                                                                                       \r \r"
    ],
    [
      0.000063,
      "\u001bk..khal-git/khal\u001b\\"
    ],
    [
      0.099535,
      "\r\u001b[0m\u001b[23m\u001b[24m\u001b[J\r\n\u001b[36mhugo@athena\u001b[00m:\u001b[34m~/tmp/khal-git/khal\u001b[00m  \u001b[32mmaster \u001b[31m✗\u001b[00m\u001b[00m \r\n▶ "
    ],
    [
      0.000016,
      "\u001b[K\u001b[75C\u001b[1A\u001b[30m10h51m\u001b[00m \u001b[33m⚑  \u001b[1B\u001b[85D"
    ],
    [
      0.000052,
      "\u001b[?1h\u001b="
    ],
    [
      1.181375,
      "\u001b[4mt\u001b[24m"
    ],
    [
      0.134599,
      "\u0008\u001b[4mt\u001b[4mo\u001b[24m"
    ],
    [
      0.112948,
      "\u0008\u0008\u001b[4mt\u001b[4mo\u001b[4mx\u001b[24m"
    ],
    [
      0.279672,
      "\u0008\u0008\u0008\u001b[24m\u001b[32mt\u001b[24m\u001b[32mo\u001b[24m\u001b[32mx\u001b[32m2\u001b[39m"
    ],
    [
      0.263295,
      "\u001b[?1l\u001b\u003e\r\r\n\u001bktox2\u001b\\"
    ],
    [
      0.169376,
      "\u001b[1mGLOB sdist-make: /home/hugo/tmp/khal-git/khal/setup.py\u001b[0m\r\n"
    ],
    [
      0.289837,
      "\u001b[1mpy27 inst-nodeps: /home/hugo/tmp/khal-git/khal/.tox/dist/khal-0.5.0.dev-124-g89bcea0-dirty.zip\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.606160,
      "\u001b[1mpy27 runtests: PYTHONHASHSEED='1408153142'\u001b[0m\r\n\u001b[1mpy27 runtests: commands[0] | py.test\u001b[0m\r\n"
    ],
    [
      0.183042,
      "\u001b[1m================================= test session starts ==================================\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000033,
      "platform linux2 -- Python 2.7.9 -- py-1.4.26 -- pytest-2.7.0"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000057,
      "rootdir: /home/hugo/tmp/khal-git/khal, inifile: "
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000021,
      "plugins: capturelog"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.087117,
      "\u001b[1m\rcollecting 0 items\u001b[0m"
    ],
    [
      0.099781,
      "\u001b[1m\rcollecting 17 items\u001b[0m"
    ],
    [
      0.004660,
      "\u001b[1m\rcollecting 21 items\u001b[0m"
    ],
    [
      0.024015,
      "\u001b[1m\rcollecting 32 items\u001b[0m"
    ],
    [
      0.003363,
      "\u001b[1m\rcollecting 34 items\u001b[0m"
    ],
    [
      0.000023,
      "\u001b[1m\rcollecting 34 items\u001b[0m"
    ],
    [
      0.000029,
      "\u001b[1m\rcollecting 34 items\u001b[0m"
    ],
    [
      0.002854,
      "\u001b[1m\rcollecting 40 items\u001b[0m"
    ],
    [
      0.004054,
      "\u001b[1m\rcollecting 52 items\u001b[0m"
    ],
    [
      0.010094,
      "\u001b[1m\rcollecting 59 items\u001b[0m"
    ],
    [
      0.000020,
      "\u001b[1m\rcollecting 59 items\u001b[0m"
    ],
    [
      0.001893,
      "\u001b[1m\rcollecting 67 items\u001b[0m"
    ],
    [
      0.000014,
      "\u001b[1m\rcollecting 67 items\u001b[0m"
    ],
    [
      0.001810,
      "\u001b[1m\rcollecting 75 items\u001b[0m"
    ],
    [
      0.000087,
      "\u001b[1m\rcollecting 75 items\u001b[0m"
    ],
    [
      0.001025,
      "\u001b[1m\rcollecting 78 items\u001b[0m"
    ],
    [
      0.000087,
      "\u001b[1m\rcollecting 78 items\u001b[0m"
    ],
    [
      0.002748,
      "\u001b[1m\rcollecting 81 items\u001b[0m"
    ],
    [
      0.000102,
      "\u001b[1m\rcollecting 81 items\u001b[0m\u001b[1m\rcollecting 81 items\u001b[0m"
    ],
    [
      0.006384,
      "\u001b[1m\rcollecting 86 items\u001b[0m"
    ],
    [
      0.000010,
      "\u001b[1m\rcollecting 86 items\u001b[0m"
    ],
    [
      0.000705,
      "\u001b[1m\rcollecting 87 items\u001b[0m"
    ],
    [
      0.000008,
      "\u001b[1m\rcollecting 87 items\u001b[0m"
    ],
    [
      0.002025,
      "\u001b[1m\rcollecting 96 items\u001b[0m"
    ],
    [
      0.000008,
      "\u001b[1m\rcollecting 96 items\u001b[0m"
    ],
    [
      0.001064,
      "\u001b[1m\rcollecting 98 items\u001b[0m"
    ],
    [
      0.000008,
      "\u001b[1m\rcollecting 98 items\u001b[0m"
    ],
    [
      0.000053,
      "\u001b[1m\rcollecting 100 items\u001b[0m"
    ],
    [
      0.003855,
      "\u001b[1m\rcollecting 105 items\u001b[0m"
    ],
    [
      0.000028,
      "\u001b[1m\rcollecting 105 items\u001b[0m"
    ],
    [
      0.000032,
      "\u001b[1m\rcollecting 105 items\u001b[0m"
    ],
    [
      0.003502,
      "\u001b[1m\rcollecting 107 items\u001b[0m"
    ],
    [
      0.000011,
      "\u001b[1m\rcollecting 107 items\u001b[0m"
    ],
    [
      0.000027,
      "\u001b[1m\rcollecting 110 items\u001b[0m"
    ],
    [
      0.002687,
      "\u001b[1m\rcollecting 113 items\u001b[0m"
    ],
    [
      0.022627,
      "\u001b[1m\rcollecting 114 items\u001b[0m"
    ],
    [
      0.000740,
      "\u001b[1m\rcollected 114 items \r\n\u001b[0m"
    ],
    [
      0.000677,
      "\r\n"
    ],
    [
      0.000005,
      "tests/backend_test.py "
    ],
    [
      0.001856,
      "."
    ],
    [
      0.013782,
      "."
    ],
    [
      0.014501,
      "."
    ],
    [
      0.016988,
      "."
    ],
    [
      0.013725,
      "."
    ],
    [
      0.006160,
      "."
    ],
    [
      0.013775,
      "."
    ],
    [
      0.013484,
      "."
    ],
    [
      0.033114,
      "F"
    ],
    [
      0.019560,
      "F"
    ],
    [
      0.046754,
      "F"
    ],
    [
      0.000913,
      "."
    ],
    [
      0.027426,
      "."
    ],
    [
      0.013207,
      "."
    ],
    [
      0.016606,
      "."
    ],
    [
      0.030300,
      "."
    ],
    [
      0.002882,
      "."
    ],
    [
      0.000812,
      "\r\n"
    ],
    [
      0.000005,
      "tests/cal_display_test.py "
    ],
    [
      0.000955,
      "."
    ],
    [
      0.000836,
      "."
    ],
    [
      0.001756,
      "."
    ],
    [
      0.003112,
      "x"
    ],
    [
      0.000705,
      "\r\n"
    ],
    [
      0.000008,
      "tests/cli_test.py "
    ],
    [
      0.022438,
      "."
    ],
    [
      0.028721,
      "."
    ],
    [
      0.023118,
      "."
    ],
    [
      0.038721,
      "."
    ],
    [
      0.005559,
      "."
    ],
    [
      0.005406,
      "."
    ],
    [
      0.005690,
      "."
    ],
    [
      0.021213,
      "."
    ],
    [
      0.007029,
      "."
    ],
    [
      0.007075,
      "."
    ],
    [
      0.003971,
      "."
    ],
    [
      0.000786,
      "\r\ntests/controller_test.py "
    ],
    [
      0.021178,
      "F"
    ],
    [
      0.016740,
      "."
    ],
    [
      0.000938,
      "\r\n"
    ],
    [
      0.000005,
      "tests/event_from_string_test.py "
    ],
    [
      0.010629,
      "."
    ],
    [
      0.004816,
      "."
    ],
    [
      0.004345,
      "."
    ],
    [
      0.005058,
      "."
    ],
    [
      0.002290,
      "."
    ],
    [
      0.002125,
      "."
    ],
    [
      0.000801,
      "\r\n"
    ],
    [
      0.000003,
      "tests/event_test.py "
    ],
    [
      0.002360,
      "."
    ],
    [
      0.015445,
      "."
    ],
    [
      0.002479,
      "."
    ],
    [
      0.021897,
      "."
    ],
    [
      0.002493,
      "."
    ],
    [
      0.002557,
      "."
    ],
    [
      0.003725,
      "."
    ],
    [
      0.001645,
      "."
    ],
    [
      0.001949,
      "."
    ],
    [
      0.003277,
      "."
    ],
    [
      0.003933,
      "."
    ],
    [
      0.002278,
      "."
    ],
    [
      0.000791,
      "\r\n"
    ],
    [
      0.000004,
      "tests/khalendar_aux_test.py "
    ],
    [
      0.002944,
      "."
    ],
    [
      0.022265,
      "."
    ],
    [
      0.002582,
      "."
    ],
    [
      0.002268,
      "."
    ],
    [
      0.002380,
      "."
    ],
    [
      0.002500,
      "."
    ],
    [
      0.012415,
      "."
    ],
    [
      0.001921,
      "."
    ],
    [
      0.004271,
      "."
    ],
    [
      0.001897,
      "."
    ],
    [
      0.001813,
      "."
    ],
    [
      0.001916,
      "."
    ],
    [
      0.003001,
      "."
    ],
    [
      0.003113,
      "."
    ],
    [
      0.003048,
      "."
    ],
    [
      0.002047,
      "."
    ],
    [
      0.003026,
      "."
    ],
    [
      0.002729,
      "."
    ],
    [
      0.005425,
      "."
    ],
    [
      0.018755,
      "."
    ],
    [
      0.002805,
      "."
    ],
    [
      0.002948,
      "."
    ],
    [
      0.003129,
      "."
    ],
    [
      0.002156,
      "."
    ],
    [
      0.002532,
      "."
    ],
    [
      0.009880,
      "."
    ],
    [
      0.001729,
      "."
    ],
    [
      0.001940,
      "."
    ],
    [
      0.002602,
      "."
    ],
    [
      0.000824,
      "\r\ntests/khalendar_test.py "
    ],
    [
      0.001908,
      "."
    ],
    [
      0.002115,
      "."
    ],
    [
      0.010424,
      "."
    ],
    [
      0.004330,
      "."
    ],
    [
      0.008325,
      "."
    ],
    [
      0.014627,
      "."
    ],
    [
      0.003753,
      "."
    ],
    [
      0.004003,
      "."
    ],
    [
      0.004086,
      "."
    ],
    [
      0.018246,
      "."
    ],
    [
      0.010825,
      "."
    ],
    [
      0.011166,
      "."
    ],
    [
      0.030583,
      "."
    ],
    [
      0.006198,
      "."
    ],
    [
      0.005495,
      "."
    ],
    [
      0.002567,
      "."
    ],
    [
      0.001687,
      "."
    ],
    [
      0.012160,
      "."
    ],
    [
      0.016055,
      "."
    ],
    [
      0.000836,
      "\r\n"
    ],
    [
      0.000004,
      "tests/settings_test.py "
    ],
    [
      0.003425,
      "."
    ],
    [
      0.003136,
      "."
    ],
    [
      0.004003,
      "."
    ],
    [
      0.001668,
      "."
    ],
    [
      0.003748,
      "."
    ],
    [
      0.000812,
      "\r\n"
    ],
    [
      0.000007,
      "tests/terminal_test.py "
    ],
    [
      0.000902,
      "."
    ],
    [
      0.000797,
      "."
    ],
    [
      0.000633,
      "."
    ],
    [
      0.000703,
      "."
    ],
    [
      0.001018,
      "."
    ],
    [
      0.000751,
      "\r\ntests/vtimezone_test.py "
    ],
    [
      0.002329,
      "."
    ],
    [
      0.002574,
      "."
    ],
    [
      0.001679,
      "."
    ],
    [
      0.000779,
      "\r\n"
    ],
    [
      0.000006,
      "tests/ui/test_widgets.py "
    ],
    [
      0.000944,
      "."
    ],
    [
      0.000297,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000013,
      "======================================= FAILURES ======================================="
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000010,
      "_______________________ test_event_rrule_this_and_future_allday ________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m    def test_event_rrule_this_and_future_allday():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        dbi = backend.SQLiteDb('home', ':memory:', locale=locale)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        dbi.update(event_rrule_this_and_future_allday,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m                   href='rrule_this_and_future_allday.ics', etag='abcd')\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        assert dbi.list() == [('rrule_this_and_future_allday.ics', 'abcd')]\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        events = dbi.get_allday_range(date(2014, 4, 30), date(2014, 9, 26))\u001b[0m\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        events = sorted(events, key=lambda x: x.start)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        assert len(events) == 6\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m\u003e       assert events[0].start == date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[31m\u001b[1mE       assert datetime.date(2014, 6, 29) == datetime.date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[31m\u001b[1mE        +  where datetime.date(2014, 6, 29) = \u003ckhal.khalendar.event.Event object at 0x7f102fa5a610\u003e.start\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[31m\u001b[1mE        +  and   datetime.date(2014, 6, 30) = date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "tests/backend_test.py:286: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "____________________ test_event_rrule_this_and_future_allday_prior _____________________"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m    def test_event_rrule_this_and_future_allday_prior():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        event_rrule_this_and_future_allday_prior = \\\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m            event_rrule_this_and_future_allday_temp.format(20140705, 20140706)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        dbi = backend.SQLiteDb('home', ':memory:', locale=locale)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m        dbi.update(event_rrule_this_and_future_allday_prior,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m                   href='rrule_this_and_future_allday.ics', etag='abcd')\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        assert dbi.list() == [('rrule_this_and_future_allday.ics', 'abcd')]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        events = dbi.get_allday_range(date(2014, 4, 30), date(2014, 9, 26))\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        events = sorted(events, key=lambda x: x.start)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        assert len(events) == 6\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m\u003e       assert events[0].start == date(2014, 6, 30)\u001b[0m\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE       assert datetime.date(2014, 6, 29) == datetime.date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[31m\u001b[1mE        +  where datetime.date(2014, 6, 29) = \u003ckhal.khalendar.event.Event object at 0x7f102f952490\u003e.start\u001b[0m"
    ],
    [
      0.000021,
      "\r\n\u001b[31m\u001b[1mE        +  and   datetime.date(2014, 6, 30) = date(2014, 6, 30)\u001b[0m\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tests/backend_test.py:316: AssertionError"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000005,
      "____________________ test_event_rrule_multi_this_and_future_allday _____________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_event_rrule_multi_this_and_future_allday():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        dbi = backend.SQLiteDb('home', ':memory:', locale=locale)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        dbi.update(event_rrule_multi_this_and_future_allday,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m                   href='event_rrule_multi_this_and_future_allday.ics', etag='abcd')\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        assert dbi.list() == [('event_rrule_multi_this_and_future_allday.ics', 'abcd')]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        events = dbi.get_allday_range(start=date(2014, 4, 30), end=date(2014, 9, 26))\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        events = sorted(events, key=lambda x: x.start)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m        assert len(events) == 6\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m\u003e       assert events[0].start == date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE       assert datetime.date(2014, 6, 29) == datetime.date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[31m\u001b[1mE        +  where datetime.date(2014, 6, 29) = \u003ckhal.khalendar.event.Event object at 0x7f102fa13410\u003e.start\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[31m\u001b[1mE        +  and   datetime.date(2014, 6, 30) = date(2014, 6, 30)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "tests/backend_test.py:369: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "___________________________ TestCalendarTest.test_new_event ____________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003ctests.controller_test.TestCalendarTest object at 0x7f102f8c5a90\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000006,
      "cal_vdir = (\u003ckhal.khalendar.khalendar.Calendar object at 0x7f102f8c5b10\u003e, \u003cFilesystemStorage(**{'path': '/tmp/pytest-4/test_new_event0'})\u003e)\r\n"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m    def test_new_event(self, cal_vdir):\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        cal, vdir = cal_vdir\u001b[0m\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        event = cal.new_event(event_today)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        cal.new(event)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m\u003e       assert ['\\x1b[1mToday:\\x1b[0m', 'a meeting'] == \\\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m            get_agenda(cal, locale)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "tests/controller_test.py:71: "
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000006,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n"
    ],
    [
      0.000009,
      "khal/controllers.py:116: in get_agenda"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m    desc = textwrap.wrap(event.compact(day), width)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "khal/khalendar/event.py:291: in compact"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m    rstring = self._compact_allday(day)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "self = \u003ckhal.khalendar.event.Event object at 0x7f102f929b90\u003e\r\n"
    ],
    [
      0.000005,
      "day = datetime.date(2015, 5, 1)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m    def _compact_allday(self, day):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m        if day \u003c self.start or day + timedelta(days=1) \u003e self.end:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m            raise ValueError('Day out of range: {}'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                             .format(dict(day=day, start=self.start,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m\u003e                                         end=self.end)))\u001b[0m\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE           ValueError: ('Something went wrong while displaying \"uid3@host1.com.ics\"', \"Day out of range: {'end': datetime.date(2015, 5, 1), 'start': datetime.date(2015, 4, 30), 'day': datetime.date(2015, 5, 1)}\")\u001b[0m"
    ],
    [
      0.000010,
      "\r\n\r\n"
    ],
    [
      0.000005,
      "khal/khalendar/event.py:305: ValueError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000062,
      "\u001b[31m\u001b[1m=================== 4 failed, 109 passed, 1 xfailed in 1.22 seconds ====================\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.029140,
      "\u001b[31mERROR: InvocationError: '/home/hugo/tmp/khal-git/khal/.tox/py27/bin/py.test'\u001b[0m\r\n"
    ],
    [
      0.019914,
      "\u001b[1mpy34 inst-nodeps: /home/hugo/tmp/khal-git/khal/.tox/dist/khal-0.5.0.dev-124-g89bcea0-dirty.zip\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.896292,
      "\u001b[1mpy34 runtests: PYTHONHASHSEED='1408153142'\u001b[0m"
    ],
    [
      0.000008,
      "\r\n\u001b[1mpy34 runtests: commands[0] | py.test\u001b[0m\r\n"
    ],
    [
      0.191598,
      "\u001b[1m================================= test session starts ==================================\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000017,
      "platform linux -- Python 3.4.3 -- py-1.4.26 -- pytest-2.7.0"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000051,
      "rootdir: /home/hugo/tmp/khal-git/khal, inifile: "
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "plugins: capturelog"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.095063,
      "\u001b[1m\rcollecting 0 items\u001b[0m"
    ],
    [
      0.036800,
      "\u001b[1m\rcollecting 0 items / 1 errors\u001b[0m"
    ],
    [
      0.004812,
      "\u001b[1m\rcollecting 4 items / 1 errors\u001b[0m"
    ],
    [
      0.148465,
      "\u001b[1m\rcollecting 15 items / 1 errors\u001b[0m"
    ],
    [
      0.019314,
      "\u001b[1m\rcollecting 17 items / 1 errors\u001b[0m"
    ],
    [
      0.000026,
      "\u001b[1m\rcollecting 17 items / 1 errors\u001b[0m"
    ],
    [
      0.000039,
      "\u001b[1m\rcollecting 17 items / 1 errors\u001b[0m"
    ],
    [
      0.004178,
      "\u001b[1m\rcollecting 23 items / 1 errors\u001b[0m"
    ],
    [
      0.007438,
      "\u001b[1m\rcollecting 35 items / 1 errors\u001b[0m"
    ],
    [
      0.025356,
      "\u001b[1m\rcollecting 42 items / 1 errors\u001b[0m"
    ],
    [
      0.000021,
      "\u001b[1m\rcollecting 42 items / 1 errors\u001b[0m"
    ],
    [
      0.002105,
      "\u001b[1m\rcollecting 50 items / 1 errors\u001b[0m"
    ],
    [
      0.000044,
      "\u001b[1m\rcollecting 50 items / 1 errors\u001b[0m"
    ],
    [
      0.001848,
      "\u001b[1m\rcollecting 58 items / 1 errors\u001b[0m"
    ],
    [
      0.000045,
      "\u001b[1m\rcollecting 58 items / 1 errors\u001b[0m"
    ],
    [
      0.001333,
      "\u001b[1m\rcollecting 61 items / 1 errors\u001b[0m"
    ],
    [
      0.000043,
      "\u001b[1m\rcollecting 61 items / 1 errors\u001b[0m"
    ],
    [
      0.001145,
      "\u001b[1m\rcollecting 64 items / 1 errors\u001b[0m"
    ],
    [
      0.000043,
      "\u001b[1m\rcollecting 64 items / 1 errors\u001b[0m"
    ],
    [
      0.000039,
      "\u001b[1m\rcollecting 64 items / 1 errors\u001b[0m"
    ],
    [
      0.008307,
      "\u001b[1m\rcollecting 69 items / 1 errors\u001b[0m"
    ],
    [
      0.000182,
      "\u001b[1m\rcollecting 69 items / 1 errors\u001b[0m"
    ],
    [
      0.001016,
      "\u001b[1m\rcollecting 70 items / 1 errors\u001b[0m"
    ],
    [
      0.000120,
      "\u001b[1m\rcollecting 70 items / 1 errors\u001b[0m"
    ],
    [
      0.002157,
      "\u001b[1m\rcollecting 79 items / 1 errors\u001b[0m"
    ],
    [
      0.000038,
      "\u001b[1m\rcollecting 79 items / 1 errors\u001b[0m"
    ],
    [
      0.001073,
      "\u001b[1m\rcollecting 81 items / 1 errors\u001b[0m"
    ],
    [
      0.000046,
      "\u001b[1m\rcollecting 81 items / 1 errors\u001b[0m"
    ],
    [
      0.000192,
      "\u001b[1m\rcollecting 83 items / 1 errors\u001b[0m"
    ],
    [
      0.004706,
      "\u001b[1m\rcollecting 88 items / 1 errors\u001b[0m"
    ],
    [
      0.000045,
      "\u001b[1m\rcollecting 88 items / 1 errors\u001b[0m"
    ],
    [
      0.000043,
      "\u001b[1m\rcollecting 88 items / 1 errors\u001b[0m"
    ],
    [
      0.004528,
      "\u001b[1m\rcollecting 90 items / 1 errors\u001b[0m"
    ],
    [
      0.000028,
      "\u001b[1m\rcollecting 90 items / 1 errors\u001b[0m"
    ],
    [
      0.000042,
      "\u001b[1m\rcollecting 93 items / 1 errors\u001b[0m"
    ],
    [
      0.003416,
      "\u001b[1m\rcollecting 96 items / 1 errors\u001b[0m"
    ],
    [
      0.027485,
      "\u001b[1m\rcollecting 97 items / 1 errors\u001b[0m"
    ],
    [
      0.000442,
      "\u001b[1m\rcollected 97 items / 1 errors \r\n\u001b[0m"
    ],
    [
      0.000780,
      "\r\n"
    ],
    [
      0.000012,
      "tests/cal_display_test.py "
    ],
    [
      0.000824,
      "."
    ],
    [
      0.000910,
      "."
    ],
    [
      0.001858,
      "."
    ],
    [
      0.018097,
      "x"
    ],
    [
      0.000909,
      "\r\ntests/cli_test.py "
    ],
    [
      0.010361,
      "F"
    ],
    [
      0.007372,
      "F"
    ],
    [
      0.007457,
      "F"
    ],
    [
      0.007296,
      "F"
    ],
    [
      0.007877,
      "F"
    ],
    [
      0.007660,
      "F"
    ],
    [
      0.007498,
      "F"
    ],
    [
      0.006968,
      "F"
    ],
    [
      0.008833,
      "F"
    ],
    [
      0.007325,
      "F"
    ],
    [
      0.010042,
      "F"
    ],
    [
      0.000893,
      "\r\n"
    ],
    [
      0.000004,
      "tests/controller_test.py "
    ],
    [
      0.020045,
      "F"
    ],
    [
      0.044949,
      "F"
    ],
    [
      0.001088,
      "\r\n"
    ],
    [
      0.000005,
      "tests/event_from_string_test.py "
    ],
    [
      0.009643,
      "F"
    ],
    [
      0.006790,
      "F"
    ],
    [
      0.005022,
      "F"
    ],
    [
      0.005023,
      "F"
    ],
    [
      0.004994,
      "F"
    ],
    [
      0.004887,
      "F"
    ],
    [
      0.000898,
      "\r\ntests/event_test.py "
    ],
    [
      0.002211,
      "."
    ],
    [
      0.013866,
      "."
    ],
    [
      0.002460,
      "."
    ],
    [
      0.016360,
      "."
    ],
    [
      0.002026,
      "."
    ],
    [
      0.002357,
      "."
    ],
    [
      0.011650,
      "F"
    ],
    [
      0.002175,
      "."
    ],
    [
      0.001941,
      "."
    ],
    [
      0.003111,
      "."
    ],
    [
      0.003450,
      "."
    ],
    [
      0.002128,
      "."
    ],
    [
      0.000885,
      "\r\ntests/khalendar_aux_test.py "
    ],
    [
      0.045778,
      "F"
    ],
    [
      0.041767,
      "F"
    ],
    [
      0.025472,
      "F"
    ],
    [
      0.024649,
      "F"
    ],
    [
      0.025785,
      "F"
    ],
    [
      0.044861,
      "F"
    ],
    [
      0.035027,
      "F"
    ],
    [
      0.002139,
      "."
    ],
    [
      0.003649,
      "."
    ],
    [
      0.001626,
      "."
    ],
    [
      0.001522,
      "."
    ],
    [
      0.001656,
      "."
    ],
    [
      0.025914,
      "F"
    ],
    [
      0.025216,
      "F"
    ],
    [
      0.026640,
      "F"
    ],
    [
      0.044162,
      "F"
    ],
    [
      0.025126,
      "F"
    ],
    [
      0.026621,
      "F"
    ],
    [
      0.025368,
      "F"
    ],
    [
      0.027135,
      "F"
    ],
    [
      0.046719,
      "F"
    ],
    [
      0.026277,
      "F"
    ],
    [
      0.025929,
      "F"
    ],
    [
      0.002171,
      "."
    ],
    [
      0.024594,
      "F"
    ],
    [
      0.026549,
      "F"
    ],
    [
      0.001587,
      "."
    ],
    [
      0.001510,
      "."
    ],
    [
      0.002005,
      "."
    ],
    [
      0.000849,
      "\r\n"
    ],
    [
      0.000003,
      "tests/khalendar_test.py "
    ],
    [
      0.002324,
      "."
    ],
    [
      0.002356,
      "."
    ],
    [
      0.008299,
      "."
    ],
    [
      0.004689,
      "."
    ],
    [
      0.006871,
      "."
    ],
    [
      0.013275,
      "."
    ],
    [
      0.004091,
      "."
    ],
    [
      0.004231,
      "."
    ],
    [
      0.004401,
      "."
    ],
    [
      0.016917,
      "."
    ],
    [
      0.010052,
      "."
    ],
    [
      0.009650,
      "."
    ],
    [
      0.026413,
      "."
    ],
    [
      0.005969,
      "."
    ],
    [
      0.004616,
      "."
    ],
    [
      0.002554,
      "."
    ],
    [
      0.001516,
      "."
    ],
    [
      0.009497,
      "."
    ],
    [
      0.013354,
      "."
    ],
    [
      0.000987,
      "\r\n"
    ],
    [
      0.000005,
      "tests/settings_test.py "
    ],
    [
      0.003263,
      "."
    ],
    [
      0.003410,
      "."
    ],
    [
      0.003750,
      "."
    ],
    [
      0.002217,
      "."
    ],
    [
      0.003607,
      "."
    ],
    [
      0.000951,
      "\r\n"
    ],
    [
      0.000005,
      "tests/terminal_test.py "
    ],
    [
      0.000901,
      "."
    ],
    [
      0.000829,
      "."
    ],
    [
      0.000794,
      "."
    ],
    [
      0.001024,
      "."
    ],
    [
      0.000989,
      "."
    ],
    [
      0.000939,
      "\r\n"
    ],
    [
      0.000004,
      "tests/vtimezone_test.py "
    ],
    [
      0.001832,
      "."
    ],
    [
      0.002366,
      "."
    ],
    [
      0.001558,
      "."
    ],
    [
      0.000887,
      "\r\n"
    ],
    [
      0.000003,
      "tests/ui/test_widgets.py "
    ],
    [
      0.001010,
      "."
    ],
    [
      0.000317,
      "\r\n"
    ],
    [
      0.000040,
      "\r\n======================================== ERRORS ========================================\r\n"
    ],
    [
      0.000023,
      "________________________ ERROR collecting tests/backend_test.py ________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000035,
      "\u001b[31m.tox/py34/lib/python3.4/site-packages/_pytest/python.py:488: in _importtestmodule\r\n    mod = self.fspath.pyimport(ensuresyspath=True)\r\n.tox/py34/lib/python3.4/site-packages/py/_path/local.py:641: in pyimport\r\n    __import__(modname)\r\nE     File \"/home/hugo/tmp/khal-git/khal/tests/backend_test.py\", line 518\r\nE       assert list(db.get_allday_range(date(1971, 03, 11))) == list()\r\nE                                                   ^\r\nE   SyntaxError: invalid token\u001b[0m"
    ],
    [
      0.000371,
      "\r\n======================================= FAILURES =======================================\r\n_______________________________ test_direct_modification _______________________________\r\n\r\nrunner = \u003ctests.cli_test.CustomCliRunner object at 0x7f3043637780\u003e\r\n\r\n\u001b[1m    def test_direct_modification(runner):\u001b[0m\r\n\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m\r\n\u001b[1m    \u001b[0m\r\n\u001b[1m        result = runner.invoke(main_khal, ['agenda'])\u001b[0m\r\n\u001b[1m\u003e       assert not result.exception\u001b[0m\r\n\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m\r\n\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m\r\n\r\ntests/cli_test.py:72: AssertionError\r\n_____________________________________ test_simple ______________________________________\r\n\r\nrunner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435db6a0\u003e\r\n\r\n\u001b[1m    def test_simple(runner):\u001b[0m"
    ],
    [
      0.000006,
      "\r\n\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000002,
      "\r\n"
    ],
    [
      0.000053,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m\r\n\u001b[1m\u003e       assert not result.exception\u001b[0m\r\n\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000075,
      "\r\n\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m\r\n\r\ntests/cli_test.py:92: AssertionError\r\n__________________________________ test_simple_color ___________________________________\r\n\r\n"
    ],
    [
      0.000010,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435f7898\u003e"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def test_simple_color(runner):\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000017,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        now = datetime.datetime.now().strftime('%d.%m.%Y')\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        result = runner.invoke(main_khal, ['new'] +\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m                               '{} 18:00 myevent'.format(now).split())\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        assert result.output == ''\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000017,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m"
    ],
    [
      0.000013,
      "\r\n\r\n"
    ],
    [
      0.000011,
      "tests/cli_test.py:116: AssertionError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000017,
      "______________________________________ test_days _______________________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000011,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435fa198\u003e"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def test_days(runner):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        runner = runner(command='agenda', showalldays=False, days=9)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        when = (datetime.datetime.now() + timedelta(days=7)).strftime('%d.%m.%Y')\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        result = runner.invoke(\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m            main_khal, ['new'] + '{} 18:00 nextweek'.format(when).split())\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        assert result.output == ''\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000010,
      "tests/cli_test.py:130: AssertionError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000018,
      "___________________________________ test_showalldays ___________________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000022,
      "\r\n"
    ],
    [
      0.000003,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f3043558358\u003e"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def test_showalldays(runner):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        runner = runner(command='agenda', showalldays=True, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert 'Tomorrow:' in result.output\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE       assert 'Tomorrow:' in ''\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE        +  where '' = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.output\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000012,
      "tests/cli_test.py:149: AssertionError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000018,
      "______________________________ test_default_command_empty ______________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000011,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435faa20\u003e"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    def test_default_command_empty(runner):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m        runner = runner(command='', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        assert result.exception\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert result.exit_code == 1\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE       assert -1 == 1\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE        +  where -1 = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exit_code\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/cli_test.py:158: AssertionError"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "____________________________ test_default_command_nonempty _____________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000011,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f304355d2e8\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_default_command_nonempty(runner):\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000018,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000010,
      "tests/cli_test.py:166: AssertionError"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000018,
      "________________________________ test_invalid_calendar _________________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000019,
      "\r\n"
    ],
    [
      0.000008,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f3043558b00\u003e"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_invalid_calendar(runner):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        runner = runner(command='', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000018,
      "\u001b[1m        result = runner.invoke(\u001b[0m\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            main_khal, ['new'] + '-a one 18:00 myevent'.split())\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "tests/cli_test.py:174: AssertionError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000019,
      "___________________________________ test_no_vevent[] ___________________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000016,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435dbac8\u003e\r\n"
    ],
    [
      0.000012,
      "tmpdir = local('/tmp/pytest-5/test_no_vevent__0'), contents = ''"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    @pytest.mark.parametrize('contents', [\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        '',\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000007,
      "\u001b[1m        u'BEGIN:VCALENDAR\\nBEGIN:VTODO\\nEND:VTODO\\nEND:VCALENDAR\\n'\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    ])\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def test_no_vevent(runner, tmpdir, contents):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m        broken_item = runner.calendars['one'].join('broken_item.ics')\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        broken_item.write(contents.encode('utf-8'), mode='wb')\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000011,
      "tests/cli_test.py:192: AssertionError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000019,
      "_________ test_no_vevent[BEGIN:VCALENDAR\r\nBEGIN:VTODO\r\nEND:VTODO\r\nEND:VCALENDAR\r\n] _________"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000012,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f3043563a58\u003e"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000011,
      "tmpdir = local('/tmp/pytest-5/test_no_vevent_BEGIN_VCALENDAR0')"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000012,
      "contents = 'BEGIN:VCALENDAR\\nBEGIN:VTODO\\nEND:VTODO\\nEND:VCALENDAR\\n'"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    @pytest.mark.parametrize('contents', [\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        '',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        u'BEGIN:VCALENDAR\\nBEGIN:VTODO\\nEND:VTODO\\nEND:VCALENDAR\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    ])\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_no_vevent(runner, tmpdir, contents):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        runner = runner(command='agenda', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        broken_item = runner.calendars['one'].join('broken_item.ics')\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m        broken_item.write(contents.encode('utf-8'), mode='wb')\u001b[0m\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert not result.exception\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE       assert not AttributeError(\"'str' object has no attribute 'decode'\",)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE        +  where AttributeError(\"'str' object has no attribute 'decode'\",) = \u003cResult AttributeError(\"'str' object has no attribute 'decode'\",)\u003e.exception\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000010,
      "tests/cli_test.py:192: AssertionError"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000018,
      "__________________________________ test_printformats ___________________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000010,
      "runner = \u003ctests.cli_test.CustomCliRunner object at 0x7f30435f7780\u003e"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_printformats(runner):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        runner = runner(command='printformats', showalldays=False, days=2)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        result = runner.invoke(main_khal)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert '\\n'.join(['longdatetimeformat: 11.12.2013 10:09',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                          'datetimeformat: 11.12. 10:09',\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                          'longdateformat: 11.12.2013',\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m                          'dateformat: 11.12.',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                          'timeformat: 10:09',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                          '']) == result.output\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[31m\u001b[1mE       assert 'longdatetime...rmat: 10:09\\n' == ''\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE         - longdatetimeformat: 11.12.2013 10:09\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE         - datetimeformat: 11.12. 10:09\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE         - longdateformat: 11.12.2013\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE         - dateformat: 11.12.\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE         - timeformat: 10:09\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "tests/cli_test.py:200: AssertionError"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000018,
      "___________________________ TestCalendarTest.test_new_event ____________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003ctests.controller_test.TestCalendarTest object at 0x7f3043581b00\u003e"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000011,
      "cal_vdir = (\u003ckhal.khalendar.khalendar.Calendar object at 0x7f30435818d0\u003e, \u003cFilesystemStorage(**{'path': '/tmp/pytest-5/test_new_event0'})\u003e)"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000017,
      "\u001b[1m    def test_new_event(self, cal_vdir):\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m        cal, vdir = cal_vdir\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        event = cal.new_event(event_today)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        cal.new(event)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert ['\\x1b[1mToday:\\x1b[0m', 'a meeting'] == \\\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m            get_agenda(cal, locale)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "tests/controller_test.py:71: "
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "khal/controllers.py:116: in get_agenda"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    desc = textwrap.wrap(event.compact(day), width)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "khal/khalendar/event.py:291: in compact"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rstring = self._compact_allday(day)\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000008,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ckhal.khalendar.event.Event object at 0x7f3043587240\u003e"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000009,
      "day = datetime.date(2015, 5, 1)"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def _compact_allday(self, day):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if day \u003c self.start or day + timedelta(days=1) \u003e self.end:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError('Day out of range: {}'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                             .format(dict(day=day, start=self.start,\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m\u003e                                         end=self.end)))\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE           ValueError: ('Something went wrong while displaying \"uid3@host1.com.ics\"', \"Day out of range: {'start': datetime.date(2015, 4, 30), 'end': datetime.date(2015, 5, 1), 'day': datetime.date(2015, 5, 1)}\")\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000009,
      "khal/khalendar/event.py:305: ValueError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000019,
      "________________________ TestCalendarTest.test_empty_recurrence ________________________"
    ],
    [
      0.000020,
      "\r\n\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.controller_test.TestCalendarTest object at 0x7f30435ae4a8\u003e"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000010,
      "cal_vdir = (\u003ckhal.khalendar.khalendar.Calendar object at 0x7f30435ae5c0\u003e, \u003cFilesystemStorage(**{'path': '/tmp/pytest-5/test_empty_recurrence0'})\u003e)"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def test_empty_recurrence(self, cal_vdir):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        cal, vdir = cal_vdir\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        cal.new(cal.new_event(dedent(\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e           u'BEGIN:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m            u'UID:no_recurrences\\r\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            u'SUMMARY:No recurrences\\r\\n'\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m            u'RRULE:FREQ=DAILY;COUNT=2;INTERVAL=1\\r\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            u'EXDATE:20110908T130000\\r\\n'\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m            u'EXDATE:20110909T130000\\r\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            u'DTSTART:20110908T130000\\r\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            u'DTEND:20110908T170000\\r\\n'\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            u'END:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000007,
      "\u001b[1m        )))\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "tests/controller_test.py:77: "
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000020,
      "khal/khalendar/khalendar.py:158: in new"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m    self._dbtool.update(event.to_ical(), event.href, event.etag)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "khal/khalendar/backend.py:254: in update"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    self._update_impl(vevent, href, etag)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000017,
      "khal/khalendar/backend.py:281: in _update_impl\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    dtstartend = aux.expand(vevent, self.locale['default_timezone'], href)\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000017,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000012,
      "s = b'FREQ=DAILY;COUNT=2;INTERVAL=1', dtstart = datetime.datetime(2011, 9, 8, 13, 0)"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000015,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000009,
      "tzinfos = None"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000018,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000008,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000011,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000018,
      "____________________________ test_construct_event_format_de ____________________________"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_construct_event_format_de():\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        for data_list, vevent in test_set_format_de:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000018,
      "\r\n"
    ],
    [
      0.000003,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000153,
      "\r\n\u001b[1m                                    **kwargs_de).to_ical()\u001b[0m\r\n\u001b[1m\u003e           assert event == vevent\u001b[0m\r\n\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m\r\n\u001b[31m\u001b[1mE             At index 141 diff: 73 != 69\u001b[0m\r\n\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m\r\n\r\ntests/event_from_string_test.py:132: AssertionError\r\n____________________________ test_construct_event_format_us ____________________________\r\n\r\n"
    ],
    [
      0.000004,
      "\u001b[1m    def test_construct_event_format_us():\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        kwargs = {\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'timeformat': '%H:%M',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'dateformat': '%m/%d',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'longdateformat': '%m/%d/%Y',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'datetimeformat': '%m/%d %H:%M',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'longdatetimeformat': '%m/%d/%Y %H:%M',\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            'default_timezone': pytz.timezone('America/New_York'),\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        }\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        for data_list, vevent in test_set_format_us:\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    **kwargs).to_ical()\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e           assert event == vevent\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000003,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE             At index 209 diff: 73 != 69\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "tests/event_from_string_test.py:169: AssertionError"
    ],
    [
      0.000046,
      "\r\n_______________________ test_construct_event_format_de_complexer _______________________\r\n\r\n"
    ],
    [
      0.000003,
      "\u001b[1m    def test_construct_event_format_de_complexer():\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        for data_list, vevent in test_set_format_de_complexer:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    **kwargs_de).to_ical()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m\u003e           assert event == vevent\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             At index 203 diff: 73 != 69\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/event_from_string_test.py:209: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "___________________________________ test_description ___________________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_description():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        for data_list, vevent in test_set_description:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    **kwargs_de).to_ical()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e           assert event == vevent\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             At index 203 diff: 73 != 69\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "tests/event_from_string_test.py:252: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "_____________________________________ test_repeat ______________________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_repeat():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        for data_list, vevent in test_set_repeat:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    description='please describe the event',\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                                    repeat='daily',\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    **kwargs_de).to_ical()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m\u003e           assert event == vevent\u001b[0m\r\n"
    ],
    [
      0.000011,
      "\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             At index 203 diff: 73 != 69\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/event_from_string_test.py:277: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "____________________________ test_description_and_location _____________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_description_and_location():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        for data_list, vevent in test_set_description_and_location:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            random.seed(1)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            event = construct_event(data_list.split(),\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    description='please describe the event',\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                                    _now=_now,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                    location='in the office',\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                                    **kwargs_de).to_ical()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e           assert event == vevent\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE           assert b'BEGIN:VEVEN...ND:VEVENT\\r\\n' == b'BEGIN:VEVENT...ND:VEVENT\\r\\n'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             At index 203 diff: 73 != 69\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[31m\u001b[1mE             Use -v to get the full diff\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/event_from_string_test.py:303: AssertionError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "____________________________________ test_event_rr _____________________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_event_rr():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        event = Event(event_dt_rr, **event_kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        assert event.recur is True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m        assert event.compact(datetime.date(2014, 4, 9)) == u'09:30-10:30: An Event ⟳'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       assert event.long() == u'09:30-10:30 09.04.2014: An Event\\nRepeat: FREQ=DAILY;COUNT=10'\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "tests/event_test.py:337: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ckhal.khalendar.event.Event object at 0x7f30431be2b0\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def long(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        \"\"\"complete description of this event in text form\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    \u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            :rtype: str\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            :returns: event description\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            \"\"\"\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if self.allday:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.001390,
      "\u001b[1m            end = self.end - timedelta(days=1)\u001b[0m"
    ],
    [
      0.000073,
      "\r\n\u001b[1m            if self.start == end:\u001b[0m\r\n\u001b[1m                rangestr = self.start.strftime(self.locale['longdateformat'])\u001b[0m\r\n\u001b[1m            else:\u001b[0m\r\n\u001b[1m                if self.start.year == self.end.year:\u001b[0m\r\n\u001b[1m                    startstr = self.start.strftime(self.locale['dateformat'])\u001b[0m\r\n\u001b[1m                else:\u001b[0m\r\n\u001b[1m                    startstr = self.start.strftime(self.locale['longdateformat'])\u001b[0m\r\n\u001b[1m                endstr = end.strftime(self.locale['longdateformat'])\u001b[0m\r\n\u001b[1m                rangestr = startstr + u' - ' + endstr\u001b[0m\r\n\u001b[1m        else:\u001b[0m\r\n\u001b[1m            # same day\u001b[0m\r\n\u001b[1m            if self.start.utctimetuple()[:3] == self.end.utctimetuple()[:3]:\u001b[0m\r\n\u001b[1m                starttime = self.start.strftime(self.locale['timeformat'])\u001b[0m\r\n\u001b[1m                endtime = self.end.strftime(self.locale['timeformat'])\u001b[0m\r\n\u001b[1m                date = self.end.strftime(self.locale['longdateformat'])\u001b[0m\r\n\u001b[1m                rangestr = starttime + u'-' + endtime + u' ' + date\u001b[0m\r\n\u001b[1m            else:\u001b[0m\r\n\u001b[1m                startstr = self.start.strftime(self.locale['longdatetimeformat'])\u001b[0m\r\n\u001b[1m                endstr = self.end.strftime(self.locale['longdatetimeformat'])\u001b[0m\r\n\u001b[1m                rangestr = startstr + u' - ' + endstr\u001b[0m\r\n\u001b[1m            if self.start.tzinfo.zone != self.locale['local_timezone'].zone:\u001b[0m\r\n\u001b[1m                # doesn't work yet\u001b[0m\r\n\u001b[1m                # TODO FIXME\u001b[0m\r\n\u001b[1m                pass\u001b[0m\r\n\u001b[1m    \u001b[0m\r\n\u001b[1m        location = u'\\nLocation: ' + self.location if \\\u001b[0m\r\n\u001b[1m            self.location is not None else u''\u001b[0m\r\n\u001b[1m        description = u'\\nDescription: ' + self.description if \\\u001b[0m\r\n\u001b[1m            self.description is not None else u''\u001b[0m\r\n\u001b[1m        repitition = u'\\nRepeat: ' + self.recurpattern if \\\u001b[0m\r\n\u001b[1m\u003e           self.recurpattern is not None else u''\u001b[0m\r\n\u001b[31m\u001b[1mE       TypeError: Can't convert 'bytes' object to str implicitly\u001b[0m\r\n\r\nkhal/khalendar/event.py:262: TypeError\r\n______________________________ TestExpand.test_expand_dt _______________________________\r\n\r\nself = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f304350f390\u003e\r\n\r\n\u001b[1m    def test_expand_dt(self):\u001b[0m\r\n\u001b[1m        vevent = _get_vevent(event_dt)\u001b[0m\r\n\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m\r\n\r\ntests/khalendar_aux_test.py:319: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nkhal/khalendar/aux.py:62: in expand\r\n\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__\r\n\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e\r\ns = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.datetime(2013, 3, 1, 14, 0)\r\ncache = False, unfold = False, forceset = False, compatible = False, ignoretz = False\r\ntzinfos = None\r\n\r\n\u001b[1m    def _parse_rfc(self, s,\u001b[0m\r\n\u001b[1m                   dtstart=None,\u001b[0m\r\n\u001b[1m                   cache=False,\u001b[0m\r\n\u001b[1m                   unfold=False,\u001b[0m\r\n\u001b[1m                   forceset=False,\u001b[0m\r\n\u001b[1m                   compatible=False,\u001b[0m\r\n\u001b[1m                   ignoretz=False,\u001b[0m\r\n\u001b[1m                   tzinfos=None):\u001b[0m\r\n\u001b[1m        global parser\u001b[0m\r\n\u001b[1m        if compatible:\u001b[0m\r\n\u001b[1m            forceset = True\u001b[0m\r\n\u001b[1m            unfold = True\u001b[0m\r\n\u001b[1m        s = s.upper()\u001b[0m\r\n\u001b[1m        if not s.strip():\u001b[0m\r\n\u001b[1m            raise ValueError(\"empty string\")\u001b[0m\r\n\u001b[1m        if unfold:\u001b[0m\r\n\u001b[1m            lines = s.splitlines()\u001b[0m\r\n\u001b[1m            i = 0\u001b[0m\r\n\u001b[1m            while i \u003c len(lines):\u001b[0m\r\n\u001b[1m                line = lines[i].rstrip()\u001b[0m\r\n\u001b[1m                if not line:\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m\r\n\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                else:\u001b[0m\r\n\u001b[1m "
    ],
    [
      0.000014,
      "                   i += 1\u001b[0m\r\n\u001b[1m        else:\u001b[0m\r\n\u001b[1m            lines = s.split()\u001b[0m\r\n\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m\r\n\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m\r\n\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m\r\n\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError\r\n______________________________ TestExpand.test_expand_dtb ______________________________\r\n\r\n"
    ],
    [
      0.000039,
      "self = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f3043581e48\u003e"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000032,
      "\u001b[1m    def test_expand_dtb(self):\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        vevent = _get_vevent(event_dtb)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000102,
      "tests/khalendar_aux_test.py:327: "
    ],
    [
      0.000009,
      "\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nkhal/khalendar/aux.py:62: in expand\r\n"
    ],
    [
      0.000006,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.datetime(2013, 3, 1, 14, 0)"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000015,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000019,
      "_____________________________ TestExpand.test_expand_dttz ______________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f30434b55c0\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m    def test_expand_dttz(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(event_dttz)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000057,
      "\r\n\r\ntests/khalendar_aux_test.py:335: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nkhal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.datetime(2013, 3, 1, 14, 0)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000029,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "______________________________ TestExpand.test_expand_dtf ______________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000019,
      "\r\n"
    ],
    [
      0.000006,
      "self = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f3043492438\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m    def test_expand_dtf(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(event_dtf)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "tests/khalendar_aux_test.py:342: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.datetime(2013, 3, 1, 14, 0)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tzinfos = None"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m            unfold = True\u001b[0m\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000018,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000019,
      "_______________________________ TestExpand.test_expand_d _______________________________"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f304348a4a8\u003e"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def test_expand_d(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        vevent = _get_vevent(event_d)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000014,
      "tests/khalendar_aux_test.py:349: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000011,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.date(2013, 3, 1)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tzinfos = None"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000027,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000011,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000029,
      "______________________________ TestExpand.test_expand_dtz ______________________________"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000055,
      "\r\nself = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f3043495208\u003e"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000028,
      "\u001b[1m    def test_expand_dtz(self):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        vevent = _get_vevent(event_dtz)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000019,
      "tests/khalendar_aux_test.py:354: "
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000019,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000027,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000023,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000020,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.date(2013, 3, 1)"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000024,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000014,
      "tzinfos = None"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000029,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000029,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000018,
      "\r\n"
    ],
    [
      0.000021,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000038,
      "_____________________________ TestExpand.test_expand_dtzb ______________________________"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000036,
      "\r\n"
    ],
    [
      0.000024,
      "self = \u003ctests.khalendar_aux_test.TestExpand object at 0x7f3043490668\u003e"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000031,
      "\u001b[1m    def test_expand_dtzb(self):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        vevent = _get_vevent(event_dtzb)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000018,
      "tests/khalendar_aux_test.py:359: "
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000019,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000058,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m\r\n"
    ],
    [
      0.000006,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000024,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000022,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.date(2013, 3, 1)"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000028,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000015,
      "tzinfos = None"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000031,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000028,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000027,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000027,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000024,
      "\r\n"
    ],
    [
      0.000034,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000036,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000028,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000024,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000020,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000039,
      "________________________ TestExpandNoRR.test_expand_dtr_exdatez ________________________"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000030,
      "\r\n"
    ],
    [
      0.000029,
      "self = \u003ctests.khalendar_aux_test.TestExpandNoRR object at 0x7f304601de48\u003e"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000030,
      "\u001b[1m    def test_expand_dtr_exdatez(self):\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m        \"\"\"a recurring event with an EXDATE in Zulu time while DTSTART is\u001b[0m"
    ],
    [
      0.000025,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            localized\"\"\"\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        vevent = _get_vevent_file('event_dtr_exdatez')\u001b[0m"
    ],
    [
      0.000447,
      "\r\n\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m\r\n\r\ntests/khalendar_aux_test.py:430: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nkhal/khalendar/aux.py:62: in expand\r\n\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__\r\n\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e\r\ns = b'FREQ=WEEKLY;UNTIL=20140725T053000Z'\r\ndtstart = datetime.datetime(2014, 6, 30, 7, 30), cache = False, unfold = False\r\nforceset = False, compatible = False, ignoretz = False, tzinfos = None\r\n\r\n"
    ],
    [
      0.000008,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m\r\n"
    ],
    [
      0.000017,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000029,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000019,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000022,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000023,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000020,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000018,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000084,
      "\r\n\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m\r\n\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000047,
      "\u001b[1m        else:\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000038,
      "______________________ TestExpandNoRR.test_expand_rrule_exdate_z _______________________"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000034,
      "\r\n"
    ],
    [
      0.000022,
      "self = \u003ctests.khalendar_aux_test.TestExpandNoRR object at 0x7f30435364a8\u003e"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000028,
      "\u001b[1m    def test_expand_rrule_exdate_z(self):\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000053,
      "\u001b[1m        \"\"\"event with not understood timezone for dtstart and zulu time form\u001b[0m\r\n"
    ],
    [
      0.000010,
      "\u001b[1m            exdate\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m            \"\"\"\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        vevent = _get_vevent_file('event_dtr_no_tz_exdatez')\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000049,
      "\r\n"
    ],
    [
      0.000007,
      "tests/khalendar_aux_test.py:438: \r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000021,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000042,
      "\r\n\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000018,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000041,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e, s = b'FREQ=MONTHLY;COUNT=6'"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "dtstart = datetime.datetime(2012, 4, 3, 10, 0), cache = False, unfold = False"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000021,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000059,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000050,
      "\u001b[1m                   tzinfos=None):\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000060,
      "\r\n\u001b[1m            lines = s.splitlines()\u001b[0m\r\n"
    ],
    [
      0.000006,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000025,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000039,
      "\r\n\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000041,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n"
    ],
    [
      0.000019,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000041,
      "\u001b[1m        else:\u001b[0m\r\n"
    ],
    [
      0.000014,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000041,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000034,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000034,
      "____________________ TestExpandNoRR.test_expand_rrule_notz_until_z _____________________"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000031,
      "\r\n"
    ],
    [
      0.000021,
      "self = \u003ctests.khalendar_aux_test.TestExpandNoRR object at 0x7f30435144e0\u003e"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000027,
      "\u001b[1m    def test_expand_rrule_notz_until_z(self):\u001b[0m"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000061,
      "\u001b[1m        \"\"\"event with not understood timezone for dtstart and zulu time form\u001b[0m"
    ],
    [
      0.000007,
      "\r\n\u001b[1m            exdate\u001b[0m\r\n"
    ],
    [
      0.000022,
      "\u001b[1m            \"\"\"\u001b[0m"
    ],
    [
      0.000011,
      "\r\n"
    ],
    [
      0.000023,
      "\u001b[1m        vevent = _get_vevent_file('event_dtr_notz_untilz')\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000028,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, new_york)\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000018,
      "\r\n"
    ],
    [
      0.000021,
      "tests/khalendar_aux_test.py:454: "
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000025,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000038,
      "khal/khalendar/aux.py:62: in expand\r\n"
    ],
    [
      0.000029,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000026,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000048,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n"
    ],
    [
      0.000011,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000018,
      "\r\n"
    ],
    [
      0.000027,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000018,
      "s = b'FREQ=WEEKLY;UNTIL=20121101T035959Z;INTERVAL=2;BYDAY=TH'"
    ],
    [
      0.000025,
      "\r\n"
    ],
    [
      0.000014,
      "dtstart = datetime.datetime(2012, 7, 26, 13, 0), cache = False, unfold = False"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000031,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000038,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000036,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000007,
      "\r\n\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000007,
      "\r\n\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000006,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000006,
      "\r\n\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m\r\n"
    ],
    [
      0.000018,
      "\r\n"
    ],
    [
      0.000006,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError\r\n"
    ],
    [
      0.000021,
      "________________________________ TestSpecial.test_count ________________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f3043530358\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "\u001b[1m    def test_count(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(vevent_count)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:570: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000019,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "s = b'FREQ=DAILY;UNTIL=20140220T070000;WKST=SU'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "dtstart = datetime.datetime(2014, 2, 3, 7, 0), cache = False, unfold = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000007,
      "\r\n\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000007,
      "\u001b[1m            forceset = True\u001b[0m\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000017,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000006,
      "\u001b[1m            lines = s.splitlines()\u001b[0m\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000019,
      "\r\n\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000020,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000006,
      "\r\n\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "_____________________________ TestSpecial.test_until_notz ______________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f3043f43668\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "\u001b[1m    def test_until_notz(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(vevent_until_notz)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:578: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000009,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000012,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "s = b'FREQ=DAILY;UNTIL=20140220T060000Z;WKST=SU'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "dtstart = datetime.datetime(2014, 2, 3, 7, 0), cache = False, unfold = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000123,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m\r\n\u001b[1m        if unfold:\u001b[0m\r\n\u001b[1m            lines = s.splitlines()\u001b[0m\r\n\u001b[1m            i = 0\u001b[0m\r\n\u001b[1m            while i \u003c len(lines):\u001b[0m\r\n\u001b[1m                line = lines[i].rstrip()\u001b[0m\r\n\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000009,
      "\r\n\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "____________________________ TestSpecial.test_until_d_notz _____________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f30435ae5f8\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_until_d_notz(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(event_until_d_notz)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:588: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "s = b'FREQ=WEEKLY;UNTIL=20140215;INTERVAL=1;BYDAY=FR'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "dtstart = datetime.date(2014, 1, 10), cache = False, unfold = False, forceset = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000082,
      "\u001b[1m                   ignoretz=False,\u001b[0m\r\n\u001b[1m                   tzinfos=None):\u001b[0m\r\n\u001b[1m        global parser\u001b[0m\r\n\u001b[1m        if compatible:\u001b[0m\r\n\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000005,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000230,
      "\u001b[1m            lines = s.splitlines()\u001b[0m\r\n\u001b[1m            i = 0\u001b[0m\r\n\u001b[1m            while i \u003c len(lines):\u001b[0m\r\n\u001b[1m                line = lines[i].rstrip()\u001b[0m\r\n\u001b[1m                if not line:\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m\r\n\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                else:\u001b[0m\r\n\u001b[1m                    i += 1\u001b[0m\r\n\u001b[1m        else:\u001b[0m\r\n\u001b[1m            lines = s.split()\u001b[0m\r\n\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000008,
      "\r\n\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "_____________________________ TestSpecial.test_latest_bug ______________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f3043563358\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_latest_bug(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(latest_bug)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:596: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "s = b'FREQ=YEARLY;BYMONTHDAY=31;BYMONTH=10', dtstart = datetime.date(2009, 10, 31)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.001237,
      "\r\n"
    ],
    [
      0.000058,
      "\u001b[1m                if not line:\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m\r\n\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                else:\u001b[0m\r\n\u001b[1m                    i += 1\u001b[0m\r\n\u001b[1m        else:\u001b[0m\r\n\u001b[1m            lines = s.split()\u001b[0m\r\n\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m\r\n\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m\r\n\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m\r\n\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError\r\n___________________________ TestSpecial.test_another_problem ___________________________\r\n\r\nself = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f3043495a90\u003e\r\n\r\n\u001b[1m    def test_another_problem(self):\u001b[0m\r\n\u001b[1m        vevent = _get_vevent(another_problem)\u001b[0m\r\n\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m\r\n\r\ntests/khalendar_aux_test.py:602: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nkhal/khalendar/aux.py:62: in expand\r\n\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__\r\n\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e\r\ns = b'FREQ=MONTHLY;BYDAY=2WE;WKST=SU', dtstart = datetime.datetime(2013, 11, 13, 19, 0)\r\ncache = False, unfold = False, forceset = False, compatible = False, ignoretz = False\r\ntzinfos = None\r\n\r\n\u001b[1m    def _parse_rfc(self, s,\u001b[0m\r\n\u001b[1m                   dtstart=None,\u001b[0m\r\n\u001b[1m                   cache=False,\u001b[0m\r\n\u001b[1m                   unfold=False,\u001b[0m\r\n\u001b[1m                   forceset=False,\u001b[0m\r\n\u001b[1m                   compatible=False,\u001b[0m\r\n\u001b[1m                   ignoretz=False,\u001b[0m\r\n\u001b[1m                   tzinfos=None):\u001b[0m\r\n\u001b[1m        global parser\u001b[0m\r\n\u001b[1m        if compatible:\u001b[0m\r\n\u001b[1m            forceset = True\u001b[0m\r\n\u001b[1m            unfold = True\u001b[0m\r\n\u001b[1m        s = s.upper()\u001b[0m\r\n\u001b[1m        if not s.strip():\u001b[0m\r\n\u001b[1m            raise ValueError(\"empty string\")\u001b[0m\r\n\u001b[1m        if unfold:\u001b[0m\r\n\u001b[1m            lines = s.splitlines()\u001b[0m\r\n\u001b[1m            i = 0\u001b[0m\r\n\u001b[1m            while i \u003c len(lines):\u001b[0m\r\n\u001b[1m                line = lines[i].rstrip()\u001b[0m\r\n\u001b[1m                if not line:\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m\r\n\u001b[1m                    lines[i-1] += line[1:]\u001b[0m\r\n\u001b[1m                    del lines[i]\u001b[0m\r\n\u001b[1m                else:\u001b[0m\r\n\u001b[1m                    i += 1\u001b[0m\r\n\u001b[1m        else:\u001b[0m\r\n\u001b[1m            lines = s.split()\u001b[0m\r\n\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m\r\n\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m\r\n\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m\r\n\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError\r\n___________________________ TestSpecial.test_event_exdate_dt ___________________________\r\n\r\nself = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f304355d588\u003e\r\n\r\n\u001b[1m    def test_event_exdate_dt(self):\u001b[0m\r\n\u001b[1m        \"\"\"recurring event, one date excluded via EXCLUDE\"\"\"\u001b[0m\r\n\u001b[1m        vevent = _get_vevent(event_exdate_dt)\u001b[0m\r\n\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m\r\n\r\n"
    ],
    [
      0.000012,
      "tests/khalendar_aux_test.py:611: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n"
    ],
    [
      0.000005,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000015,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000021,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000026,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000022,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000017,
      "\r\n"
    ],
    [
      0.000026,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e, s = b'FREQ=DAILY;COUNT=10'"
    ],
    [
      0.000013,
      "\r\n"
    ],
    [
      0.000020,
      "dtstart = datetime.datetime(2014, 7, 2, 19, 0), cache = False, unfold = False"
    ],
    [
      0.000012,
      "\r\n"
    ],
    [
      0.000020,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000019,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000021,
      "\u001b[1m                   unfold=False,\u001b[0m\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000010,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000011,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000020,
      "__________________________ TestSpecial.test_event_exdates_dt ___________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000016,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f3043587278\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_event_exdates_dt(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        \"\"\"recurring event, two dates excluded via EXCLUDE\"\"\"\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(event_exdates_dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:621: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000024,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m\r\n"
    ],
    [
      0.000017,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000007,
      "\r\n\r\n"
    ],
    [
      0.000006,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e, s = b'FREQ=DAILY;COUNT=10'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "dtstart = datetime.datetime(2014, 7, 2, 19, 0), cache = False, unfold = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000022,
      "\u001b[1m                    del lines[i]\u001b[0m\r\n"
    ],
    [
      0.000005,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000008,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000017,
      "__________________________ TestSpecial.test_event_exdatesl_dt __________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestSpecial object at 0x7f30435090b8\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_event_exdatesl_dt(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m        \"\"\"recurring event, three dates exclude via two EXCLUDEs\"\"\"\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "\u001b[1m        vevent = _get_vevent(event_exdatesl_dt)\u001b[0m"
    ],
    [
      0.000004,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000009,
      "tests/khalendar_aux_test.py:631: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e, s = b'FREQ=DAILY;COUNT=10'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "dtstart = datetime.datetime(2014, 7, 2, 19, 0), cache = False, unfold = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "forceset = False, compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000020,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000018,
      "____________________________ TestRDate.test_rrule_and_rdate ____________________________"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\r\n"
    ],
    [
      0.000011,
      "self = \u003ctests.khalendar_aux_test.TestRDate object at 0x7f3043541550\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def test_rrule_and_rdate(self):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        vevent = _get_vevent(rrule_and_rdate)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m\u003e       dtstart = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000010,
      "tests/khalendar_aux_test.py:679: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000011,
      "s = b'FREQ=MONTHLY;COUNT=6;INTERVAL=2', dtstart = datetime.datetime(2013, 3, 1, 14, 0)"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "cache = False, unfold = False, forceset = False, compatible = False, ignoretz = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000009,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000133,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000013,
      "\r\n\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m\r\n\r\n.tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError\r\n______________________________ TestRDate.test_rrule_past _______________________________\r\n\r\nself = \u003ctests.khalendar_aux_test.TestRDate object at 0x7f304348aa90\u003e\r\n\r\n\u001b[1m    def test_rrule_past(self):\u001b[0m\r\n\u001b[1m        vevent = _get_vevent(event_r_past)\u001b[0m"
    ],
    [
      0.000007,
      "\r\n\u001b[1m\u003e       dtstarts = aux.expand(vevent, berlin)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "\r\n"
    ],
    [
      0.000009,
      "tests/khalendar_aux_test.py:684: "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "khal/khalendar/aux.py:62: in expand"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    rrule = dateutil.rrule.rrulestr(rrulestr, dtstart=vevent['DTSTART'].dt)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1371: in __call__"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m    return self._parse_rfc(s, **kwargs)\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ "
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "self = \u003cdateutil.rrule._rrulestr object at 0x7f3045fb5128\u003e, s = b'FREQ=YEARLY'"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "dtstart = datetime.date(1965, 4, 23), cache = False, unfold = False, forceset = False"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000010,
      "compatible = False, ignoretz = False, tzinfos = None"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000015,
      "\u001b[1m    def _parse_rfc(self, s,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   dtstart=None,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   cache=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   unfold=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   forceset=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   compatible=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                   ignoretz=False,\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                   tzinfos=None):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        global parser\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        if compatible:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            forceset = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            unfold = True\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m        s = s.upper()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if not s.strip():\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            raise ValueError(\"empty string\")\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        if unfold:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.splitlines()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            i = 0\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m            while i \u003c len(lines):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                line = lines[i].rstrip()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                if not line:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                elif i \u003e 0 and line[0] == \" \":\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    lines[i-1] += line[1:]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                    del lines[i]\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m                else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                    i += 1\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      "\u001b[1m        else:\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m            lines = s.split()\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m\u003e       if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000013,
      "\u001b[1m                                                  s.startswith('RRULE:'))):\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000014,
      "\u001b[31m\u001b[1mE                                                 TypeError: 'str' does not support the buffer interface\u001b[0m"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000012,
      ".tox/py34/lib/python3.4/site-packages/dateutil/rrule.py:1287: TypeError"
    ],
    [
      0.000005,
      "\r\n"
    ],
    [
      0.000164,
      "\u001b[31m\u001b[1m=============== 40 failed, 56 passed, 1 xfailed, 1 error in 1.53 seconds ===============\u001b[0m\r\n"
    ],
    [
      0.087948,
      "\u001b[31mERROR: InvocationError: '/home/hugo/tmp/khal-git/khal/.tox/py34/bin/py.test'\u001b[0m\r\n_______________________________________ summary ________________________________________\r\n\u001b[31mERROR:   py27: commands failed\u001b[0m\r\n\u001b[31mERROR:   py34: commands failed\u001b[0m\r\n"
    ],
    [
      0.007222,
      "\u001b[1m\u001b[3m%\u001b[23m\u001b[1m\u001b[0m                                                                                       \r \r"
    ],
    [
      0.000081,
      "\u001bk..khal-git/khal\u001b\\"
    ],
    [
      0.095838,
      "\r\u001b[0m\u001b[23m\u001b[24m\u001b[J\r\n\u001b[36mhugo@athena\u001b[00m:\u001b[34m~/tmp/khal-git/khal\u001b[00m  \u001b[32mmaster \u001b[31m✗\u001b[00m\u001b[00m \r\n▶ \u001b[K\u001b[72C\u001b[1A\u001b[30m10h52m\u001b[00m \u001b[33m⚑  \u001b[31m1 ↵\u001b[00m\u001b[1B\u001b[85D"
    ],
    [
      0.000035,
      "\u001b[?1h\u001b="
    ],
    [
      0.713485,
      "\r\r\n"
    ]
  ]
}